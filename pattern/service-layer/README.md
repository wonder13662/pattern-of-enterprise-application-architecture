## 서비스 계층(Service Layer)

<p align="center">
  <img src="./service-layer-001.png" alt="domain-model" title="Domain model" width="601px" height="541 px"/>
</p>

일반적으로 엔터프라이즈 애플리케이션은 저장하는 데이터와 구현하는 논리에 대한 다양한 인터페이스를 필요로 한다. 이러한 인터페이스에는 데이터 로더, 사용자 인터페이스, 통합 게이트웨이 등이 있다. 이러한 인터페이스는 용도는 서로 다르지만 데이터에 접근 및 조작하고 비즈니스 논리를 호출하기 위해 애플리케이션과의 상호작용을 공통으로 필요로 한다. 상호작용은 여러 리소스에 걸친 트랜잭션과 수행할 여러 응답의 조율을 포함하는 복잡한 작업일 수 있다. 상호작용의 논리를 각 인터페이스에서 별도로 인코딩하면 중복이 많이 발생한다.

서비스 계층(Service Layer)은 클라이언트 계층을 인터페이스하는 관점에서 애플리케이션의 경계와 사용 가능한 작업의 집합을 정의한다. 서비스 계층은 작업을 구현할 때 트랜잭션을 제어하며 응답을 조율하면서 애플리케이션의 비즈니스 논리를 캡슐화한다.

### 작동 원리

서비스 계층은 앞서 언급한 특성을 위반하지 않으면서 몇 가지 다른 방법으로 구현할 수 있다. 차이점은 서비스 계층 인터페이스 배후의 역할 할당에서 나타난다. 구현의 다양한 가능성을 설명하기 전에 몇 가지 기본 사항을 정리해보자.

일종의 "비즈니스 논리": 서비스 계층은 [트랜잭션 스크립트](https://github.com/wonder13662/pattern-of-enterprise-application-architecture/tree/main/pattern/transaction-script)나 [도메인 모델](https://github.com/wonder13662/pattern-of-enterprise-application-architecture/tree/main/pattern/domain-model)과 마찬자기로 비즈니스 논리를 구현하기 위한 패턴이다. 필자를 비롯한 다수의 설계자는 "비즈니스 논리"를 "도메인 논리"와 "애플리케이션 논리"로 나누기를 좋아한다. 도메인 논리는 순수하게 문제 도메인(예: 계약의 수익 인식을 계산하는 전략)을 집중적으로 처리하며, 애플리케이션 논리는 애플리케이션 역할[Writing Effective Use Cases](https://www.amazon.com/Writing-Effective-Cases-Software-Development-ebook-dp-B00I077Z1M/dp/B00I077Z1M/ref=mt_other?_encoding=UTF8&me=&qid=1614416300)(예: 계산된 수익 인식을 계약 관리자와 통합된 애플리케이션에 알림)을 처리한다. 애플리케이션 논리는 종종 "워크플로 논리"라고도 하는데, "워크플로"를 다른 의미로 해석하는 사람들도 있다.

[도메인 모델](https://github.com/wonder13662/pattern-of-enterprise-application-architecture/tree/main/pattern/domain-model)은 전통적인 디자인 패턴을 사용해 복잡성을 관리하고 도메인 논리 중복을 예방한다는 면에서 [트랜잭션 스크립트](https://github.com/wonder13662/pattern-of-enterprise-application-architecture/tree/main/pattern/transaction-script)보다 나은 방법이다. 그런데 애플리케이션 논리를 순수 도메인 객체 클래스에 넣으면 두 가지 부작용이 있다.

1. 도메인 객체 클래스가 특정 애플리케이션에서 재사용하기 어려워진다.
2. 두 가지 종류의 논리를 동일한 클래스에 넣으면 다시 구현하기 어렵다. 예를 들어 나중에 애플리케이션 논리를 워크플로 툴로 분리할 필요가 있을 때 다시 구현하기 어렵다.

이러한 이유로 서비스 계층은 각 유형의 비즈니스 논리를 별도의 계층으로 분리함으로써 계층화의 일반적인 장점을 제공하고 순수 도메인 객체 클래스를 애플리케이션 간에 재사용하기 쉽게 만들어준다.

구현의 변형: 구현의 기본적인 두 가지 변형으로 도메인 파사드(domain facade) 방식과 작업 스크립트(operation script) 방식이 있다. 도메인 파사드 방식에서는 서비스 계층을 [도메인 모델](https://github.com/wonder13662/pattern-of-enterprise-application-architecture/tree/main/pattern/domain-model) 위에서 씬(Thin) 파사드의 집합으로 구현한다. 파사드를 구현하는 클래스는 비즈니스 논리를 전혀 구현하지 않으며, [도메인 모델](https://github.com/wonder13662/pattern-of-enterprise-application-architecture/tree/main/pattern/domain-model)이 모든 비즈니스 논리를 구현한다. 씬(Thin) 파사드는 클라이언트 계층이 애플리케이션과 상호작용하기 위한 작업 집합과 경계를 형성하며 서비스 계층의 근본적인 특성을 나타낸다.

작업 스크립트 방식에서는 서비스 계층을 리치 클래스 집합으로 구현한다. 이러한 클래스 집합은 애플리케이션 논리는 직접 구현하지만, 도메인 논리는 캡슐화된 도메인 객체 클래스로 위임한다. 서비스 계층의 클라이언트에 제공되는 작업은 여러 스크립트로 구현되며, 이러한 스크립트는 연관된 논리의 특정 주제 영역을 정의하는 한 클래스에 포함된다. 이러한 각 클래스는 애플리케이션 "서비스"를 형성하며 서비스 형식의 이름이 "서비스"로 끝나는 경우도 흔하다. 서비스 계층은 이러한 여러 애플리케이션 서비스 클래스로 이뤄지며, 이러한 서비스 클래스는 각자의 역할과 공통 동작을 추상화하고 [계층 상위 형식]()을 확장해야 한다.

원격 호출에 대한 고려: 서비스 계층 클래스의 인터페이스는 클라이언트 계층에 제공되는 애플리케이션 작업의 집합을 선언하므로 기본 정의상 거의 굵은 입자 인터페이스이다. 따라서 서비스 계층 클래스는 인터페이스 세분성(interface granularity)의 관점에서 보면 원격 호출에 적합하다.

그러나 원격 호출은 먼저 객체 분산이라는 비용을 치러야 사용할 수 있다. 서비스 계층 메서드 시그니처를 [데이터 전송 객체]()를 받게 변경하려면 상당히 부담스러운 추가 작업을 해야 할 수 있다. 특히 [도메인 모델](https://github.com/wonder13662/pattern-of-enterprise-application-architecture/tree/main/pattern/domain-model)이 복잡하고 복잡한 업데이트를 위한 리치 편집 UI를 사용하는 경우에는 이 추가 작업을 절대 과소평가해서는 안 된다. 상당히 힘들고 고통스러운 과정이며 아마도 객체-관계형 매핑 다음으로 힘든 작업일 것이다. [분산 객체 설계의 첫 번째 규칙]()을 기억하자.

우선은 로컬로 호출할 수 있고 도메인 객체를 받는 메서드 시그니처를 사용하는 서비스 계층으로 시작하는 것이 좋다. 원격이 꼭 필요할 때는 서비스 계층에 [원격 파사드]()를 넣거나 아니면 서비스 계층 객체에서 원격 인터페이스를 구현하면 된다. 애플리케이션에 웹 기반 UI나 웹 서비스 기반 통합 게이트웨이가 있는 경우, 비즈니스 논리를 서버 페이지나 웹 서비스와 별도의 프로세스로 실행해야 한다는 법은 없다. 실제로 같은 장소에 배치하는 방식으로도 확장성을 저해하지 않고 상당한 수준의 개발 시간을 줄이고 런타임 응답 시간을 개선할 수 있다.

**서비스 및 작업 식별**: 서비스 계층 경계에 필요한 작업을 식별하는 과정은 아주 간단하다. 이러한 작업은 서비스 계층 클라이언트의 필요성에 의해 결정되는데, 가장 중요하고 우선적인 서비스 계층 클라이언트는 일반적으로 사용자 인터페이스다. 사용자 인터페이스는 사용자가 애플리케이션으로 수행하려는 유스 케이스를 지원하도록 설계되므로 서비스 계층 작업을 식별하는 시작점은 애플리케이션의 유스 케이스 모델과 사용자 인터페이스 설계다.

엔터프라이즈 애플리케이션의 유스 케이스는 도메인 객체를 대상으로 하는 조금 지루한 "CRUD"(생성, 읽기, 갱신, 삭제) 유스 케이스인 경우가 많다. 즉, 도메인 객체를 만들고 이러한 객체의 컬렉션을 읽거나 업데이트하는 작업이다. 필자의 경험에 비춰보면 CRUD 유스 케이스와 서비스 계층 작업 간에는 거의 항상 일대일 대응 관계가 있다.

반면 이러한 유스 케이스를 실행해야 하는 애플리케이션의 역할은 전혀 지루하지 않다. 유효성 검사는 물론이고, 애플리케이션에서 도메인 객체를 생성, 업데이트, 삭제할 때 다른 사람이나 다른 통합된 애플리케이션에 알려야 하는 경우가 증가했다. 이러한 응답은 서비스 계층 작업에 의해 조율되고 트랜잭션을 통해 원자성을 유지해야 한다.

서비스 계층 추상화를 식별해 관련 작업을 그룹화하는 것을 직관적으로 할 수 있으면 정말 좋겠지만 이 영역에 대해서는 체험적 조언만 있을 뿐 확실한 처방전은 없다. 아주 간단한 애플리케이션인 경우에는 애플리케이션 이름을 그대로 딴 추상화 하나를 사용해도 충분할 것이다. 필자의 경험에 비춰보면 대규모 애플리케이션은 각각 아키텍쳐 계층의 스택을 가로지르는 완전한 수직 슬라이스를 포함하는 여러 "하위 시스템"으로 분할된다. 이 경우 필자는 하위 시스템당 하나씩 하위 시스템의 이름을 딴 추상화를 선호한다. 다른 방식으로는 도메인 모델의 주요 분할을 반영하는 추상화가 있다. 예를 들어, 하위 시스템 분할과 다른 경우(예: ContractService, ProductService), 그리고 추상화의 이름이 애플리케이션 동작을 반영하는 경우(예: RecognitionService)가 있다.

### 자바구현
서비스 계층 클래스는 도메인 파사드 방식과 작업 스크립트 방식에서 모두 POJO나 상태 비저장 세션으로 구현할 수 있다. POJO는 EJB 컨테이너에 배포하지 않아도 실행할 수 있으므로 테스트하기는 쉬울 수 있다. 대신 POJO 서비스 계층은 분산된 켄테이너 관리 트랜잭션 서비스에 연결하기 어려울 수 있으며, 특히 서비스 간 호출이 필요할 때는 더 어렵다. 반면 EJB는 컨테이너 관리 분산 트랜잭션이 기본적으로 제공되지만 테스트와 실행을 위해 컨테이너에 배포해야 한다. 각자 상황에 더 적절한 방법을 선택하면 된다.

필자가 J2EE 상에서 서비스 계층을 만들 때 선호하는 방법은 EJB 2.0 상태 비저장 세션 빈과 로컬 인터페이스를 사용하고 작업 스크립트 방식으로 POJO 도메인 객체 클래스에 위임하는 것이다. EJB가 분산된 컨테이너 관리 트랜잭션을 제공하기 때문에 상태 비저장 세션 빈으로 서비스 계층을 구현하면 아주 편리하다. 또한 EJB 2.0에 추가된 로컬 인터페이스를 사용하면 까다로운 객체 분산 문제를 예빵하면서 유용한 트랜잭션 서비스를 마음껏 활용할 수 있다.

또한 자바 관련 내용으로서, 서비스 계층과 J2EE 패턴 서적[Alur et al.]() 및 [Marinescu]()에 나온 세션 파사드 패턴과의 차이를 명확하게 해둘 필요가 있다. 세션 파사드는 엔터티 빈에 원격 호출이 너무 많을 때 성능 저하를 방지하는 방법으로 고안됐다. 따라서 세션 빈을 엔터티 빈의 파사드로 사용하는 처방을 내렸다. 반면 서비스 계층은 역할을 팩터링으로 분리해 중복을 방지하고 재사용성을 향상하기 위해 만들어졌으며, 특정 기술에 얽매이지 않는 아키텍쳐 패턴이다. 실제로 서비스 계층에 영감을 제공한 애플리케이션 경계 패턴[Cockburn PloP]()은 EJB보다 3년 전에 나왔다. 세션 파사드는 서비스 계층과 비슷하다고 할 수 있지만, 현재의 명칭이나 범위, 그리고 사용하는 용도를 감안하면 둘은 분명히 다르다.

### 사용 시점
서비스 계층의 장점은 여러 종류의 클라이언트에 제공하는 애플리케이션 작업의 공통적인 집합을 정의하고 각 작업에 대한 애플리케이션의 응답을 조율한다는 것이다. 이러한 응답에는 여러 트랜잭션 리소스에 걸쳐 원자성을 유지해야 하는 애플리케이션 논리가 포함될 수 있다. 따라서 애플리케이션에 비즈니스 논리를 사용하는 클라이언트 종류가 둘 이상이고, 유스 케이스의 복잡한 응답에 여러 트랜잭션 리소스가 포함되는 경우, 분산되지 않는 아키텍쳐라도 컨테이너 관리 트랜잭션과 함께 서비스 계층을 활용하는 것이 합리적이다.

사용할 필요가 없는 경우를 묻는 질문에는 대답하기가 좀 더 쉽다. 애플리케이션에 비즈니스 논리를 사용하는 클라이언트가 한 종류(예: 사용자 인터페이스)밖에 없고 이 유스 케이스 응답에 여러 트랜잭션 리소스가 포함되지 않는 경우에는 서비스 계층이 필요 없을 것이다. 이 경우 페이지 컨트롤러를 사용해 트랜잭션을 수동으로 제어하고, 필요한 응답을 조율하며, 필요에 따라 데이터 원본 계층으로 직접 위임할 수 있다.

그러나 나중에라도 두 번째 종류의 클라이언트를 구상하거나 유스 케이스 응답에 두 번째 트랜잭션 리소스를 추가하는 경우를 감안하면 처음부터 서비스 계층을 설계하는 것이 좋을 수 있다.

### 참고 자료
서비스 계층에 영감을 준 패턴은 알리스테어 콕번(Alistair Cockburn)의 애플리케이션 경계 패턴[Cockburn PloP]()이며, 이에 해당하는 선행 기술은 그리 많지 않다. 원격 서비스라는 맥락[Alpert et al.]()에서는 분산 시스템에서 파사드의 역할을 설명한다. 이 내용과 세션 파사드에 대한 맥락[Alur et al.]()에서는 분산 시스템에서 파사드의 역할을 설명한다. 이 내용과 세션 파사드에 대한 [Alur et al.]()과 [Marinescu]()의 다양한 프레젠테이션을 비교 및 대조하면 큰 도움이 될 것이다. 서비스 계층 작업 내에서 조율해야 하는 애플리케이션 역할이라는 주제에 관해서는 동작의 계약[Cockburn UC]()이라는 유스 케이스에 대한 콕번의 설명이 아주 유용하다. "시스템 작업"[Coleman et al.]()에 대한 퓨전 방법론(Fusion methodology)의 관점도 알아두자.

### 참고 자료
