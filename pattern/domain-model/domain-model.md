## 도메인 모델
동작과 데이터를 모두 포함하는 도메인의 객체 모델
<p align="center">
  <img src="./domain-model-001.png" alt="domain-model" title="Domain model" width="602px" height="472px"/>
</p>

비즈니스 논리는 경우에 따라 아주 복잡할 수 있다. 규칙과 논리는 매우 다양한 사례와 동작의 변형을 나타내며, 객체는 이러한 복잡성을 처리하기 위해 고안됐다. 도메인 모델(Domain Model)은 각 객체가 하나의 기업과 같이 복잡하거나 주문서의 내용 한 줄과 같이 같단한, 의미 있는 하나의 대상을 나타내는 상호 연결된 객체의 연결망으로 이뤄진다.

### 작동 원리
애플리케이션에서 도메인 모델을 구현하는 과정은 비즈니스 영역을 모델링하는 객체로 구성된 계층을 구성하는 과정이다. 이러한 객체 중에는 일상적인 업무에 사용되는 비즈니스 데이터로 나타내는 객체도 있고 비즈니스 규칙을 나타내는 객체도 있다. 이러한 데이터와 프로세스는 프로세스와 작업 대상 데이터를 가깝게 배치하기 위한 클러스터를 형성한다.

객체지향 도메인 모델은 종종 데이터베이스 모델과 비슷해 보이기도 하지만 실제로 둘 사이에는 차이점이 많다. 도메인 모델은 데이터와 프로세스가 혼합된 구조이고, 다중 값 속성과 복잡한 연갈망을 가지며, 상속을 사용한다.

이 때문에 주로 두 가지 형식의 도메인 모델이 사용된다. 단순 도메인 모델은 대부분의 도메인 객체가 각 데이터베이스 테이블과 일치하므로 외형상 데이터베이스 설계와 거의 비슷해 보인다. 반면 리치 도메인 모델은 상속, 전략, 다양한 "Gang of Four" 패턴, 그리고 복잡하게 상호 연결된 객체의 연결망을 포함하므로 데이터베이스 설계와는 상당히 다르게 보일 수 있다. 리치 도메인 모델은 복잡한 논리를 나타내는 데 적합하지만 데이터베이스에 매핑하기는 어렵다. 단순 도메인 모델에는 [활성 레코드]()를 사용할 수 있지만 리치 도메인 모델에는 [데이터 매퍼]()가 필요하다.

비즈니스 동작은 자주 변경해야 하므로 이 계층을 손쉽게 수정, 구축, 테스트할 수 있게 만드는 일이 아주 중요하다. 이를 위해서는 이를 위해서는 도메인 모델과 시스템의 다른 계층 간의 결합을 최소화해야 한다. 다른 여러 계층화 패턴에서도 도메인 모델과 시스템의 다른 부분 간의 의존성을 최소화하기 위한
방법들이 많이 사용된다.

도메인 모델에는 여러 다양한 범위를 사용할 수 있다. 가장 단순한 경우에는 파일에서 전체 객체 그래프를 읽어 메모리에 저장하는 단일 사용자 애플리케이션이다. 데스크톱 애플리케이션은 이런 방식으로 작동할 수 있지만 다중 계층 IS 애플리케이션에는 객체가 너무 많기 때문에 이러한 방식을 그대로 도입하기 어렵다. 모든 객체를 메모리에 저장하려면 메모리가 너무 많이 필요하고 시간도 많이 걸린다. 객체지향 데이터베이스의 장점은 실제로는 메모리와 디스크 사이에서 객체를 이동하면서 모든 객체가 메모리에 있는 것처럼 사용할 수 있게 해준다는 것이다.

객체지향 데이터베이스를 사용할 수 없으면 필요한 일을 직접해야 한다. 이 경우 보통은 한 세션이 연관된 모든 객체의 객체 그래프를 가져오는 일을 한다. 여기에는 당연히 모든 객체가 포함되는 것은 아니며 보통은 모든 클래스가 포함되지도 않는다. 예를 들어, 특정한 계약서 집합을 찾아보려는 경우 작업 범위 내의 계약서에 참조된 상품만 가져올 수 있다. 그리고 단순히 계약과 수익 인식에 대한 계산만 할 때는 상품 객체는 아예 가져오지 않는 경우도 있다. 정확히 어떤 객체를 메모리로 가져오는지 데이터베이스 매핑 객체에 의해 좌우된다.

서버에 대한 여러 호출에 동일한 객체 그래프가 필요한 경우 서버 상태를 저장해야 하는데, [서버 상태 저장]() 절에서 이 내용을 설명했다.

도메인 논리와 관련해서 흔히 하는 고민은 도메인 객체가 과하게 비대해지는 것이다. 예를 들어, 주문을 처리하는 화면을 만들 때 일부 주문의 동작은 특정 주문에만 필요할 수 있다. 이러한 동작을 모든 주문에 추가하면 주문 클래스가 특정 사례에 한 번만 사용되는 동작으로 가득 차서 지나치게 커질 수 있다. 이러한 문제를 예방하기 위해 사람들은 어떤 동작이 일반적인지 여부를 먼저 고려한 후, 일반적인 동작은 주문 클래스에 넣고, 특정한 동작은 일종의 사례별 클래스([트랜잭션 스크립트]()나 프레젠테이션 자체에 해당하는)에 넣는 방법을 생각했다.
